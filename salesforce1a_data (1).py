# -*- coding: utf-8 -*-
"""Salesforce1A Data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Id0e1bR3vrpfBq1k8XSiLaE2wAFklgja

https://aroussi.com/post/python-yahoo-finance
"""

# https://aroussi.com/post/python-yahoo-finance
import yfinance as yf
# apple and amazon
data = yf.download("AAPL AMZN", start="2016-10-01", end="2017-04-30",
                   group_by="ticker")
print(data)

pip install yfinance pandas numpy matplotlib scikit-learn torch

import yfinance as yf, pandas as pd, numpy as np, matplotlib.pyplot as plt
from pathlib import Path
# https://gist.github.com/yashveersinghsohi/060d1dc1311142f387d1c0ba8267e230
# for dowloading S&P 500
TICKERS = ["AAPL","MSFT","GOOGL","AMZN","META","NVDA","TSLA","SPY", "^GSPC"]
START, END = "2015-01-01", None

data = yf.download(" ".join(TICKERS), start=START, end=END, auto_adjust=True, actions=True)

stacked = (data.stack(level=1)
        .rename_axis(index=["Date","Ticker"])
        .reset_index()
        .sort_values(["Ticker","Date"]))

stacked['Ticker'] = stacked['Ticker'].replace('^GSPC', 'S&P 500')

summary = (stacked
      .assign(Return=lambda d: d.groupby("Ticker")["Close"].pct_change())
      .groupby("Ticker")
      .agg(n_days=("Date","nunique"),
          start=("Date","min"), end=("Date","max"),
          mean_ret=("Return","mean"), vol_ret=("Return","std"),
          ann_vol=("Return", lambda x: x.std()*np.sqrt(252)),
          avg_dollar_vol=("Close", "mean")))

summary

print(stacked.columns)

# import matplotlib.pyplot as plt

# Find the right price column
# price_cols = [c for c in stacked.columns if "adj" in c.lower() and "close" in c.lower()]
# if not price_cols:
#     price_cols = [c for c in stacked.columns if "close" in c.lower()]  # fallback
# price_col = price_cols[0]  # take the first match

# plt.figure(figsize=(12,6))
# for ticker in stacked["Ticker"].unique():
#     subset = stacked[stacked["Ticker"] == ticker]
#     plt.plot(subset["Date"], subset[price_col], label=ticker)

# plt.title("Closing Prices")
# plt.xlabel("Date")
# plt.ylabel("Price")
# plt.legend()
# plt.show()
import matplotlib.pyplot as plt

# Find the right price column
price_cols = [c for c in stacked.columns if "adj" in c.lower() and "close" in c.lower()]
if not price_cols:
    price_cols = [c for c in stacked.columns if "close" in c.lower()]  # fallback
price_col = price_cols[0]  # take the first match

fig, axes = plt.subplots(2, 1, figsize=(12, 12))
# plt.figure(figsize=(12,6))
all_tickers = stacked["Ticker"].unique()
all_tickers_no_sp = np.delete(all_tickers, np.where(all_tickers == 'S&P 500'))

for ticker in all_tickers_no_sp:
    subset = stacked[stacked["Ticker"] == ticker]
    axes[0].plot(subset["Date"], subset[price_col], label=ticker)

axes[0].set_title('Closing Prices Except S&P 500')
axes[0].legend()
axes[0].set_xlabel("Date")
axes[0].set_ylabel("Price")

subset = stacked[stacked["Ticker"] == 'S&P 500']
axes[1].plot(subset["Date"], subset[price_col], label='S&P 500')
axes[1].set_title('Closing Prices For S&P 500')
axes[1].legend()
axes[1].set_xlabel("Date")
axes[1].set_ylabel("Price")
# plt.title("Closing Prices")
plt.show();

"""This plot shows how different companies’ stock prices change over time. Each line is a company, with dates on the bottom and prices on the side. You can quickly see which stocks go up, which ones move together, and which ones are more stable or jumpy. It’s basically a simple way to compare how the stocks have done in the past."""

import matplotlib.pyplot as plt

# --- Find the right price column (Adj Close or Close) ---
price_cols = [c for c in stacked.columns if "adj" in c.lower() and "close" in c.lower()]
if not price_cols:
    price_cols = [c for c in stacked.columns if "close" in c.lower()]
price_col = price_cols[0]

# --- Rolling calculations ---
window = 30  # 30 trading days (~1.5 months)

plt.figure(figsize=(12,6))

for ticker in all_tickers_no_sp:
    subset = stacked[stacked["Ticker"] == ticker].copy()

    # Rolling 30-day moving average of price
    subset["Rolling_Mean"] = subset[price_col].rolling(window).mean()

    # Rolling 30-day volatility = std dev of daily returns
    subset["Rolling_Vol"] = subset[price_col].pct_change().rolling(window).std()

    # Plot the two series
    plt.plot(subset["Date"], subset["Rolling_Mean"], label=f"{ticker} {window}D MA")
    plt.plot(subset["Date"], subset["Rolling_Vol"], label=f"{ticker} {window}D Vol")

plt.title(f"{window}-Day Moving Average & Volatility")
plt.xlabel("Date")
plt.ylabel("Value")
plt.legend()
plt.show()


target = "AAPL 30-Day Moving Average % Volatility"

# --- Find the right price column (Adj Close or Close) ---
price_cols = [c for c in stacked.columns if "adj" in c.lower() and "close" in c.lower()]
if not price_cols:
    price_cols = [c for c in stacked.columns if "close" in c.lower()]
price_col = price_cols[0]

# --- Rolling calculations ---
window = 30  # 30 trading days (~1.5 months)

plt.figure(figsize=(12,6))

#
subset = stacked[stacked["Ticker"] == "AAPL"].copy()

# Rolling 30-day moving average of price
subset["Rolling_Mean"] = subset[price_col].rolling(window).mean()

# Rolling 30-day volatility = std dev of daily returns
subset["Rolling_Vol"] = subset[price_col].pct_change().rolling(window).std()

# Plot the two series
plt.plot(subset["Date"], subset["Rolling_Mean"], label=f"AAPL {window}D MA")

plt.plot(subset["Date"], subset["Rolling_Vol"], label=f"AAPL {window}D Vol")
#

plt.title(f"{target}: {window}-Day Moving Volatility")
plt.xlabel("Date")
plt.ylabel("Volatility (std of returns)")
plt.legend()
plt.tight_layout()
plt.show()








target = "GOOGL 30-Day Moving Average % Volatility"

# --- Find the right price column (Adj Close or Close) ---
price_cols = [c for c in stacked.columns if "adj" in c.lower() and "close" in c.lower()]
if not price_cols:
    price_cols = [c for c in stacked.columns if "close" in c.lower()]
price_col = price_cols[0]

# --- Rolling calculations ---
window = 30  # 30 trading days (~1.5 months)

plt.figure(figsize=(12,6))

#
subset = stacked[stacked["Ticker"] == "GOOGL"].copy()

# Rolling 30-day moving average of price
subset["Rolling_Mean"] = subset[price_col].rolling(window).mean()

# Rolling 30-day volatility = std dev of daily returns
subset["Rolling_Vol"] = subset[price_col].pct_change().rolling(window).std()

# Plot the two series
plt.plot(subset["Date"], subset["Rolling_Mean"], label=f"GOOGL {window}D MA")

plt.plot(subset["Date"], subset["Rolling_Vol"], label=f"GOOGL {window}D Vol")
#

plt.title(f"{target}: {window}-Day Moving Volatility")
plt.xlabel("Date")
plt.ylabel("Volatility (std of returns)")
plt.legend()
plt.tight_layout()
plt.show()







target = "TSLA 30-Day Moving Average % Volatility"

# --- Find the right price column (Adj Close or Close) ---
price_cols = [c for c in stacked.columns if "adj" in c.lower() and "close" in c.lower()]
if not price_cols:
    price_cols = [c for c in stacked.columns if "close" in c.lower()]
price_col = price_cols[0]

# --- Rolling calculations ---
window = 30  # 30 trading days (~1.5 months)

plt.figure(figsize=(12,6))

#
subset = stacked[stacked["Ticker"] == "TSLA"].copy()

# Rolling 30-day moving average of price
subset["Rolling_Mean"] = subset[price_col].rolling(window).mean()

# Rolling 30-day volatility = std dev of daily returns
subset["Rolling_Vol"] = subset[price_col].pct_change().rolling(window).std()

# Plot the two series
plt.plot(subset["Date"], subset["Rolling_Mean"], label=f"TSLA {window}D MA")

plt.plot(subset["Date"], subset["Rolling_Vol"], label=f"TSLA {window}D Vol")
#

plt.title(f"{target}: {window}-Day Moving Volatility")
plt.xlabel("Date")
plt.ylabel("Volatility (std of returns)")
plt.legend()
plt.tight_layout()
plt.show()






target = "SPY 30-Day Moving Average % Volatility"

# --- Find the right price column (Adj Close or Close) ---
price_cols = [c for c in stacked.columns if "adj" in c.lower() and "close" in c.lower()]
if not price_cols:
    price_cols = [c for c in stacked.columns if "close" in c.lower()]
price_col = price_cols[0]

# --- Rolling calculations ---
window = 30  # 30 trading days (~1.5 months)

plt.figure(figsize=(12,6))

#
subset = stacked[stacked["Ticker"] == "SPY"].copy()

# Rolling 30-day moving average of price
subset["Rolling_Mean"] = subset[price_col].rolling(window).mean()

# Rolling 30-day volatility = std dev of daily returns
subset["Rolling_Vol"] = subset[price_col].pct_change().rolling(window).std()

# Plot the two series
plt.plot(subset["Date"], subset["Rolling_Mean"], label=f"SPY {window}D MA")

plt.plot(subset["Date"], subset["Rolling_Vol"], label=f"SPY {window}D Vol")
#

plt.title(f"{target}: {window}-Day Moving Volatility")
plt.xlabel("Date")
plt.ylabel("Volatility (std of returns)")
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# --- Find the right price column (Adj Close or Close) ---
price_cols = [c for c in stacked.columns if "adj" in c.lower() and "close" in c.lower()]
if not price_cols:
    price_cols = [c for c in stacked.columns if "close" in c.lower()]
price_col = price_cols[0]

# --- Rolling calculations ---
window = 30  # 30 trading days (~1.5 months)

plt.figure(figsize=(12,6))

for ticker in ['S&P 500']:
    subset = stacked[stacked["Ticker"] == ticker].copy()

    # Rolling 30-day moving average of price
    subset["Rolling_Mean"] = subset[price_col].rolling(window).mean()

    # Rolling 30-day volatility = std dev of daily returns
    subset["Rolling_Vol"] = subset[price_col].pct_change().rolling(window).std()

    # Plot the two series
    plt.plot(subset["Date"], subset["Rolling_Mean"], label=f"{ticker} {window}D MA")
    plt.plot(subset["Date"], subset["Rolling_Vol"], label=f"{ticker} {window}D Vol")

plt.title(f"{window}-Day Moving Average & Volatility")
plt.xlabel("Date")
plt.ylabel("Value")
plt.legend()
plt.show()


# --- Find the right price column (Adj Close or Close) ---
price_cols = [c for c in stacked.columns if "adj" in c.lower() and "close" in c.lower()]
if not price_cols:
    price_cols = [c for c in stacked.columns if "close" in c.lower()]
price_col = price_cols[0]

# --- Rolling calculations ---
window = 30  # 30 trading days (~1.5 months)

plt.figure(figsize=(12,6))

for ticker in ['AAPL']:
    subset = stacked[stacked["Ticker"] == ticker].copy()

    # Rolling 30-day moving average of price
    subset["Rolling_Mean"] = subset[price_col].rolling(window).mean()

    # Rolling 30-day volatility = std dev of daily returns
    subset["Rolling_Vol"] = subset[price_col].pct_change().rolling(window).std()

    # Plot the two series
    plt.plot(subset["Date"], subset["Rolling_Mean"], label=f"{ticker} {window}D MA")
    plt.plot(subset["Date"], subset["Rolling_Vol"], label=f"{ticker} {window}D Vol")

plt.title(f"{window}-Day Moving Average & Volatility")
plt.xlabel("Date")
plt.ylabel("Value")
plt.legend()
plt.show()








# --- Find the right price column (Adj Close or Close) ---
price_cols = [c for c in stacked.columns if "adj" in c.lower() and "close" in c.lower()]
if not price_cols:
    price_cols = [c for c in stacked.columns if "close" in c.lower()]
price_col = price_cols[0]

# --- Rolling calculations ---
window = 30  # 30 trading days (~1.5 months)

plt.figure(figsize=(12,6))

for ticker in ['GOOGL']:
    subset = stacked[stacked["Ticker"] == ticker].copy()

    # Rolling 30-day moving average of price
    subset["Rolling_Mean"] = subset[price_col].rolling(window).mean()

    # Rolling 30-day volatility = std dev of daily returns
    subset["Rolling_Vol"] = subset[price_col].pct_change().rolling(window).std()

    # Plot the two series
    plt.plot(subset["Date"], subset["Rolling_Mean"], label=f"{ticker} {window}D MA")
    plt.plot(subset["Date"], subset["Rolling_Vol"], label=f"{ticker} {window}D Vol")

plt.title(f"{window}-Day Moving Average & Volatility")
plt.xlabel("Date")
plt.ylabel("Value")
plt.legend()
plt.show()








# --- Find the right price column (Adj Close or Close) ---
price_cols = [c for c in stacked.columns if "adj" in c.lower() and "close" in c.lower()]
if not price_cols:
    price_cols = [c for c in stacked.columns if "close" in c.lower()]
price_col = price_cols[0]

# --- Rolling calculations ---
window = 30  # 30 trading days (~1.5 months)

plt.figure(figsize=(12,6))

for ticker in ['TSLA']:
    subset = stacked[stacked["Ticker"] == ticker].copy()

    # Rolling 30-day moving average of price
    subset["Rolling_Mean"] = subset[price_col].rolling(window).mean()

    # Rolling 30-day volatility = std dev of daily returns
    subset["Rolling_Vol"] = subset[price_col].pct_change().rolling(window).std()

    # Plot the two series
    plt.plot(subset["Date"], subset["Rolling_Mean"], label=f"{ticker} {window}D MA")
    plt.plot(subset["Date"], subset["Rolling_Vol"], label=f"{ticker} {window}D Vol")

plt.title(f"{window}-Day Moving Average & Volatility")
plt.xlabel("Date")
plt.ylabel("Value")
plt.legend()
plt.show()

"""this plot shows the moving average of price over 30 days, so we can see the trends without all the daily ups and downs

"""

# price and moving averages for Amazon
amzn = stacked[stacked["Ticker"] == "AMZN"].copy()
amzn["MA20"] = amzn["Close"].rolling(20).mean()
amzn["MA100"] = amzn["Close"].rolling(100).mean()

plt.figure(figsize=(12,6))
plt.plot(amzn["Date"], amzn["Close"], label="AMZN Price")
plt.plot(amzn["Date"], amzn["MA20"], label="20D MA")
plt.plot(amzn["Date"], amzn["MA100"], label="100D MA")
plt.title("Amazon Price with 20D & 100D Moving Averages")
plt.xlabel("Date")
plt.ylabel("Price")
plt.legend()
plt.show()


aapl = stacked[stacked["Ticker"] == "AAPL"].copy()
aapl["MA20"] = aapl["Close"].rolling(20).mean()
aapl["MA100"] = aapl["Close"].rolling(100).mean()

plt.figure(figsize=(12,6))
plt.plot(aapl["Date"], aapl["Close"], label="AAPL Price")
plt.plot(aapl["Date"], aapl["MA20"], label="20D MA")
plt.plot(aapl["Date"], aapl["MA100"], label="100D MA")
plt.title("Apple Price with 20D & 100D Moving Averages")
plt.xlabel("Date")
plt.ylabel("Price")
plt.legend()
plt.show()



googl = stacked[stacked["Ticker"] == "GOOGL"].copy()
googl["MA20"] = googl["Close"].rolling(20).mean()
googl["MA100"] = googl["Close"].rolling(100).mean()

plt.figure(figsize=(12,6))
plt.plot(googl["Date"], googl["Close"], label="GOOGL Price")
plt.plot(googl["Date"], googl["MA20"], label="20D MA")
plt.plot(googl["Date"], googl["MA100"], label="100D MA")
plt.title("Google Price with 20D & 100D Moving Averages")
plt.xlabel("Date")
plt.ylabel("Price")
plt.legend()
plt.show()


tsla = stacked[stacked["Ticker"] == "TSLA"].copy()
tsla["MA20"] = tsla["Close"].rolling(20).mean()
tsla["MA100"] = tsla["Close"].rolling(100).mean()

plt.figure(figsize=(12,6))
plt.plot(tsla["Date"], tsla["Close"], label="TSLA Price")
plt.plot(tsla["Date"], tsla["MA20"], label="20D MA")
plt.plot(tsla["Date"], tsla["MA100"], label="100D MA")
plt.title("Tesla Price with 20D & 100D Moving Averages")
plt.xlabel("Date")
plt.ylabel("Price")
plt.legend()
plt.show()


spy = stacked[stacked["Ticker"] == "SPY"].copy()
spy["MA20"] = spy["Close"].rolling(20).mean()
spy["MA100"] = spy["Close"].rolling(100).mean()

plt.figure(figsize=(12,6))
plt.plot(spy["Date"], spy["Close"], label="SPY Price")
plt.plot(spy["Date"], spy["MA20"], label="20D MA")
plt.plot(spy["Date"], spy["MA100"], label="100D MA")
plt.title("S&P 500 Price with 20D & 100D Moving Averages")
plt.xlabel("Date")
plt.ylabel("Price")
plt.legend()
plt.show()

import math
tickers = stacked["Ticker"].dropna().unique().tolist()
n = len(tickers)
cols = 3 if n >= 6 else 2
rows = math.ceil(n / cols)
fig, axes = plt.subplots(rows, cols, figsize=(5*cols, 3.2*rows), sharex=True)
if isinstance(axes, plt.Axes):  # if only 1 axis returned
    axes = [axes]
else:
    axes = axes.flatten()

for i, t in enumerate(tickers):
  ax = axes[i]
  temp = stacked[stacked["Ticker"] == t].copy()
  temp["MA20"] = temp["Open"].rolling(20).mean()
  temp["MA100"] = temp["Open"].rolling(100).mean()
  ax.plot(temp["Date"], temp["Close"], label= f"{t} Price")
  ax.plot(temp["Date"], temp["MA20"], label="20D MA")
  ax.plot(temp["Date"], temp["MA100"], label="100D MA")
  ax.set_title(f"{t} Price with 20D & 100D Moving Averages")
  ax.set_xlabel("Date")
  ax.set_ylabel("Price")

fig.suptitle("Open Price with 20D & 100D Moving Averages", fontsize=16, y=0.98)
plt.subplots_adjust(wspace=0.25, hspace=0.35)
plt.legend()
plt.show()

#Daily Returns Distribution
amzn["Return"] = amzn["Close"].pct_change()

plt.figure(figsize=(8,5))
plt.hist(amzn["Return"].dropna(), bins=50, alpha=0.7)
plt.title("Amazon Daily Returns Distribution")
plt.xlabel("Daily Return")
plt.ylabel("Frequency")
plt.show()


aapl["Return"] = aapl["Close"].pct_change()

plt.figure(figsize=(8,5))
plt.hist(aapl["Return"].dropna(), bins=50, alpha=0.7)
plt.title("Apple Daily Returns Distribution")
plt.xlabel("Daily Return")
plt.ylabel("Frequency")
plt.show()



#Daily Returns Distribution
googl["Return"] = googl["Close"].pct_change()

plt.figure(figsize=(8,5))
plt.hist(googl["Return"].dropna(), bins=50, alpha=0.7)
plt.title("Google Daily Returns Distribution")
plt.xlabel("Daily Return")
plt.ylabel("Frequency")
plt.show()



#Daily Returns Distribution
tsla["Return"] = tsla["Close"].pct_change()

plt.figure(figsize=(8,5))
plt.hist(tsla["Return"].dropna(), bins=50, alpha=0.7)
plt.title("Tesla Daily Returns Distribution")
plt.xlabel("Daily Return")
plt.ylabel("Frequency")
plt.show()



#Daily Returns Distribution
spy["Return"] = spy["Close"].pct_change()

plt.figure(figsize=(8,5))
plt.hist(spy["Return"].dropna(), bins=50, alpha=0.7)
plt.title("S&P 500 Daily Returns Distribution")
plt.xlabel("Daily Return")
plt.ylabel("Frequency")
plt.show()

import math

#Daily Returns Distribution
tickers = stacked["Ticker"].dropna().unique().tolist()
n = len(tickers)
cols = 3 if n >= 6 else 2
rows = math.ceil(n / cols)
fig, axes = plt.subplots(rows, cols, figsize=(5*cols, 3.2*rows), sharex=True)
if isinstance(axes, plt.Axes):  # if only 1 axis returned
    axes = [axes]
else:
    axes = axes.flatten()

for i, t in enumerate(tickers):
  ax = axes[i]
  temp = stacked[stacked["Ticker"] == t].copy()
  temp["Return"] = temp["Close"].pct_change()
  ax.hist(temp["Return"].dropna(), bins=50, alpha=0.7)
  ax.set_title(f"{t} Daily Returns Distribution")
  ax.set_xlabel("Daily Return")
  ax.set_ylabel("Frequency")

fig.suptitle("Daily Returns Distribution", fontsize=16, y=0.98)
plt.subplots_adjust(wspace=0.25, hspace=0.35)
plt.legend()
plt.show();

#Rolling Volatility (since 2020)
amzn_recent = amzn[amzn["Date"] >= "2020-01-01"].copy()
amzn_recent["RollingVol30"] = amzn_recent["Return"].rolling(30).std()

plt.figure(figsize=(12,6))
plt.plot(amzn_recent["Date"], amzn_recent["RollingVol30"], label="30D Volatility")
plt.title("Amazon 30-Day Rolling Volatility (Since 2020)")
plt.xlabel("Date")
plt.ylabel("Volatility")
plt.legend()
plt.show()


aapl_recent = aapl[aapl["Date"] >= "2020-01-01"].copy()
aapl_recent["RollingVol30"] = aapl_recent["Return"].rolling(30).std()

plt.figure(figsize=(12,6))
plt.plot(aapl_recent["Date"], aapl_recent["RollingVol30"], label="30D Volatility")
plt.title("Apple 30-Day Rolling Volatility (Since 2020)")
plt.xlabel("Date")
plt.ylabel("Volatility")
plt.legend()
plt.show()



googl_recent = googl[googl["Date"] >= "2020-01-01"].copy()
googl_recent["RollingVol30"] = googl_recent["Return"].rolling(30).std()

plt.figure(figsize=(12,6))
plt.plot(googl_recent["Date"], googl_recent["RollingVol30"], label="30D Volatility")
plt.title("Google 30-Day Rolling Volatility (Since 2020)")
plt.xlabel("Date")
plt.ylabel("Volatility")
plt.legend()
plt.show()



tsla_recent = tsla[tsla["Date"] >= "2020-01-01"].copy()
tsla_recent["RollingVol30"] = tsla_recent["Return"].rolling(30).std()

plt.figure(figsize=(12,6))
plt.plot(tsla_recent["Date"], tsla_recent["RollingVol30"], label="30D Volatility")
plt.title("Tesla 30-Day Rolling Volatility (Since 2020)")
plt.xlabel("Date")
plt.ylabel("Volatility")
plt.legend()
plt.show()


spy_recent = spy[spy["Date"] >= "2020-01-01"].copy()
spy_recent["RollingVol30"] = spy_recent["Return"].rolling(30).std()

plt.figure(figsize=(12,6))
plt.plot(spy_recent["Date"], spy_recent["RollingVol30"], label="30D Volatility")
plt.title("S&P 500 30-Day Rolling Volatility (Since 2020)")
plt.xlabel("Date")
plt.ylabel("Volatility")
plt.legend()
plt.show()

#Rolling Volatility (since 2020)
tickers = stacked["Ticker"].dropna().unique().tolist()
n = len(tickers)
cols = 3 if n >= 6 else 2
rows = math.ceil(n / cols)
fig, axes = plt.subplots(rows, cols, figsize=(5*cols, 3.2*rows), sharex=True)
if isinstance(axes, plt.Axes):  # if only 1 axis returned
    axes = [axes]
else:
    axes = axes.flatten()

for i, t in enumerate(tickers):
  ax = axes[i]
  temp = stacked[stacked["Ticker"] == t].copy()
  temp["Return"] = temp["Close"].pct_change()
  temp_recent = temp[temp['Date'] >= "2020-01-01"].copy()
  temp_recent["RollingVol30"] = temp_recent["Return"].rolling(30).std()
  ax.plot(temp_recent["Date"], temp_recent["RollingVol30"], label="30D Volatility")
  ax.set_title(f"{t} 30-Day Rolling Volatility (Since 2020)")
  ax.set_xlabel("Date")
  ax.set_ylabel("Volatility")

fig.suptitle(" 30-Day Rolling Volatility (Since 2020)", fontsize=16, y=0.98)
plt.subplots_adjust(wspace=0.25, hspace=0.35)
plt.legend()
plt.show();

#Trading Volume
plt.figure(figsize=(12,6))
plt.plot(amzn["Date"], amzn["Volume"], label="AMZN Volume", color="orange")
plt.title("Amazon Trading Volume Over Time")
plt.xlabel("Date")
plt.ylabel("Volume")
plt.legend()
plt.show()


plt.figure(figsize=(12,6))
plt.plot(aapl["Date"], aapl["Volume"], label="AAPL Volume", color="orange")
plt.title("Apple Trading Volume Over Time")
plt.xlabel("Date")
plt.ylabel("Volume")
plt.legend()
plt.show()




#Trading Volume
plt.figure(figsize=(12,6))
plt.plot(googl["Date"], googl["Volume"], label="GOOGL Volume", color="orange")
plt.title("Google Trading Volume Over Time")
plt.xlabel("Date")
plt.ylabel("Volume")
plt.legend()
plt.show()




#Trading Volume
plt.figure(figsize=(12,6))
plt.plot(tsla["Date"], tsla["Volume"], label="TSLA Volume", color="orange")
plt.title("Tesla Trading Volume Over Time")
plt.xlabel("Date")
plt.ylabel("Volume")
plt.legend()
plt.show()




#Trading Volume
plt.figure(figsize=(12,6))
plt.plot(spy["Date"], spy["Volume"], label="SPY Volume", color="orange")
plt.title("S&P 500 Trading Volume Over Time")
plt.xlabel("Date")
plt.ylabel("Volume")
plt.legend()
plt.show()

#Trading Volume
tickers = stacked["Ticker"].dropna().unique().tolist()
n = len(tickers)
cols = 3 if n >= 6 else 2
rows = math.ceil(n / cols)
fig, axes = plt.subplots(rows, cols, figsize=(5*cols, 3.2*rows), sharex=True)
if isinstance(axes, plt.Axes):  # if only 1 axis returned
    axes = [axes]
else:
    axes = axes.flatten()

for i, t in enumerate(tickers):
  ax = axes[i]
  temp = stacked[stacked["Ticker"] == t].copy()
  ax.plot(temp["Date"], temp["Volume"], label=f"{t} Volume", color="orange")
  ax.set_title(f"{t} Trading Volume Over Time")
  ax.set_xlabel("Date")
  ax.set_ylabel("Price")

fig.suptitle("Trading Volume Over Time", fontsize=16, y=0.98)
plt.subplots_adjust(wspace=0.25, hspace=0.35)
plt.legend()
plt.show()

plt.figure(figsize=(12,6))
for t in all_tickers_no_sp:
    sub = stacked[stacked["Ticker"] == t].sort_values("Date").copy()
    sub["Return"] = sub["Close"].pct_change()
    sub["CumRet"] = (1 + sub["Return"].fillna(0)).cumprod() - 1
    plt.plot(sub["Date"], sub["CumRet"], label=t)

plt.title("Cumulative Returns Since Start")
plt.xlabel("Date"); plt.ylabel("Cumulative Return")
plt.legend(); plt.show()

import math
import matplotlib.pyplot as plt
import pandas as pd

# --- Setup: ensure datetime + find price column ---
stacked["Date"] = pd.to_datetime(stacked["Date"])
price_cols = [c for c in stacked.columns if "adj" in c.lower() and "close" in c.lower()]
if not price_cols:
    price_cols = [c for c in stacked.columns if "close" in c.lower()]
price_col = price_cols[0]

# --- Compute drawdown per ticker ---
df = stacked.sort_values(["Ticker", "Date"]).copy()
df["CumMax"] = df.groupby("Ticker")[price_col].cummax()
df["Drawdown"] = df[price_col] / df["CumMax"] - 1  # (price / peak) - 1  → 0 at peaks, negative when below
""
# --- Small multiples: one subplot per ticker ---
tickers = df["Ticker"].dropna().unique().tolist()
n = len(tickers)
cols = 3 if n >= 6 else 2
rows = math.ceil(n / cols)

fig, axes = plt.subplots(rows, cols, figsize=(5*cols, 3.2*rows), sharex=True)
if isinstance(axes, plt.Axes):  # if only 1 axis returned
    axes = [axes]
else:
    axes = axes.flatten()

for i, t in enumerate(tickers):
    ax = axes[i]
    sub = df[df["Ticker"] == t].sort_values("Date").copy()
    sub = sub.dropna(subset=["Drawdown"])
    # area + line so dips are obvious
    ax.fill_between(sub["Date"], sub["Drawdown"], 0, step="pre", alpha=0.35)
    ax.plot(sub["Date"], sub["Drawdown"], linewidth=0.9)
    ax.axhline(0, linewidth=0.8)
    ax.set_title(t)
    ax.set_ylim(min(-0.9, sub["Drawdown"].min()), 0.02)  # cap top slightly above 0

# Hide any empty axes
for j in range(i+1, len(axes)):
    axes[j].set_visible(False)

fig.suptitle("Drawdown from Prior Peak (by Ticker)  •  lower = deeper loss from last high", y=1.02)
plt.tight_layout()
plt.show()

"""drawdown plot shows when each stock was furthest below its recent peak so we can line those dips up with specific headlines.This helps us see if lots of news or bad headlines line up with bigger drops and slower recoveries or even happen right before them."""

!pip -q install kagglehub

import os, shutil, kagglehub

src_path = kagglehub.dataset_download("notlucasp/financial-news-headlines")
print("KaggleHub cached at:", src_path)

dst_dir = "/content/news_data"
shutil.copytree(src_path, dst_dir, dirs_exist_ok=True)

# === Recreate `stacked` if it's missing ===
import pandas as pd, yfinance as yf

# Use your tickers; edit if needed
TICKERS = ["AAPL","MSFT","GOOGL","AMZN","META","NVDA","TSLA","SPY"]
START, END = "2015-01-01", None

if "stacked" not in globals():
    # Reuse existing yfinance output if present; otherwise download
    if "data" not in globals():
        data = yf.download(" ".join(TICKERS), start=START, end=END,
                           auto_adjust=False, actions=False, progress=False)

    # Convert yfinance wide (MultiIndex columns) -> long format with Date/Ticker columns
    if isinstance(data.columns, pd.MultiIndex):
        stacked = (
            data.stack(level=-1)
                .rename_axis(index=["Date","Ticker"])
                .reset_index()
                .sort_values(["Ticker","Date"])
        )
    else:

        df = data.reset_index().copy()
        df["Ticker"] = TICKERS[0]
        stacked = df.sort_values(["Ticker","Date"])

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# --- Prep ---
stacked = stacked.copy()
stacked["Date"] = pd.to_datetime(stacked["Date"])

# find price column
price_cols = [c for c in stacked.columns if "adj" in c.lower() and "close" in c.lower()]
if not price_cols:
    price_cols = [c for c in stacked.columns if "close" in c.lower()]
price_col = price_cols[0]

# daily returns (if not already there)
if "Return" not in stacked.columns:
    stacked = stacked.sort_values(["Ticker","Date"])
    stacked["Return"] = stacked.groupby("Ticker")[price_col].pct_change()

# loop all tickers and plot the 4 mini-charts
for T in sorted(stacked["Ticker"].unique()):
    sub = stacked[stacked["Ticker"] == T].sort_values("Date").copy()
    sub["MA20"]   = sub[price_col].rolling(20).mean()
    sub["MA100"]  = sub[price_col].rolling(100).mean()
    sub["Vol30"]  = sub["Return"].rolling(30).std()
    if "Volume" in sub.columns:
        sub["VolMA30"] = sub["Volume"].rolling(30).mean()
    else:
        sub["VolMA30"] = np.nan

    fig, axes = plt.subplots(2, 2, figsize=(12, 8))
    fig.suptitle(f"{T} — Price/Trend, Returns, Volatility, Volume", y=1.02)

    # Price + moving averages
    ax = axes[0,0]
    ax.plot(sub["Date"], sub[price_col], label="Price")
    ax.plot(sub["Date"], sub["MA20"],  label="20D MA")
    ax.plot(sub["Date"], sub["MA100"], label="100D MA")
    ax.set_title("Price + MAs"); ax.legend()

    # Returns histogram
    ax = axes[0,1]
    ax.hist(sub["Return"].dropna(), bins=50, alpha=0.75)
    ax.set_title("Daily Returns (hist)")

    # Rolling 30D volatility (zoom recent)
    ax = axes[1,0]
    recent = sub[sub["Date"] >= "2020-01-01"]
    ax.plot(recent["Date"], recent["Vol30"], label="30D Vol")
    ax.set_title("Rolling 30D Volatility (since 2020)"); ax.legend()

    # Volume + 30D avg
    ax = axes[1,1]
    if "Volume" in sub.columns:
        ax.bar(sub["Date"], sub["Volume"], alpha=0.4, label="Volume")
        ax.plot(sub["Date"], sub["VolMA30"], label="30D Avg Vol")
        ax.set_title("Trading Volume"); ax.legend()
    else:
        ax.text(0.5, 0.5, "No Volume column", ha="center", va="center", transform=ax.transAxes)
        ax.set_axis_off()

    plt.tight_layout()
    plt.show()

import pandas as pd


if "df" not in globals():
    # Minimal fallback: build labels from `stacked` if needed
    assert "stacked" in globals(), "Run the cell that builds `stacked` or `df` first."
    df = stacked.copy()
    df["Date"] = pd.to_datetime(df["Date"])
    df = df.sort_values(["Ticker","Date"])
    g = df.groupby("Ticker")
    # Targets
    df["y_open_t1"]   = g["Open"].shift(-1)
    df["y_ret_oo_t1"] = (g["Open"].shift(-1) / df["Open"]) - 1

# --- Find the S&P 500 ticker in your data ---
sp_candidates = ["S&P 500", "^GSPC", "SPX", "SP500", "SP-500", "SPY"]  # try index and SPY proxy
tickers = df["Ticker"].astype(str).unique().tolist()

chosen = None
for cand in sp_candidates:
    for t in tickers:
        if t.strip().lower() == cand.strip().lower():
            chosen = t
            break
    if chosen:
        break

if chosen is None:
    raise ValueError(f"Couldn't find an S&P 500 ticker in {tickers}. Try adding '^GSPC' or SPY.")

# --- Define label columns and optional direction label ---
label_cols = [c for c in df.columns if c.startswith("y_")]
if "y_ret_oo_t1" in df.columns and "y_dir_t1" not in df.columns:
    df["y_dir_t1"] = (df["y_ret_oo_t1"] > 0).astype(int)  # 1=up, 0=down
    label_cols = label_cols + ["y_dir_t1"]

# --- Print results ---
sp_labels = df[df["Ticker"] == chosen][["Date","Ticker"] + label_cols].dropna(subset=label_cols)
print(f"Using ticker: {chosen}")
print("Label columns:", label_cols)
print(sp_labels.tail(10))  # show recent label values

#  class balance for the up/down label
if "y_dir_t1" in sp_labels.columns:
    counts = sp_labels["y_dir_t1"].value_counts().rename(index={0:"down",1:"up"})
    print("Up/Down counts:", dict(counts))

# Kaggle Data loading and putting in the content folder
!pip -q install kagglehub

import os, shutil, kagglehub

src_path = kagglehub.dataset_download("notlucasp/financial-news-headlines")
print("KaggleHub cached at:", src_path)

dst_dir = "/content/news_data"
shutil.copytree(src_path, dst_dir, dirs_exist_ok=True)

cnbc = pd.read_csv('news_data/cnbc_headlines.csv')
guardian = pd.read_csv('news_data/guardian_headlines.csv')
reuters = pd.read_csv('news_data/reuters_headlines.csv')

PATTERNS = {
    "AAPL":  r'(?<![A-Z0-9])\$?AAPL(?![A-Z0-9])|\bApple\b',
    "MSFT":  r'(?<![A-Z0-9])\$?MSFT(?![A-Z0-9])|\bMicrosoft\b',
    "GOOGL": r'(?<![A-Z0-9])\$?(?:GOOGL|GOOG)(?![A-Z0-9])|\b(?:Alphabet|Google)\b',
    "AMZN":  r'(?<![A-Z0-9])\$?AMZN(?![A-Z0-9])|\bAmazon\b',
    # acoid the common meta
    "META":  r'(?<![A-Z0-9])\$?META(?![A-Z0-9])|\bMeta Platforms?\b|\bFacebook\b',
    "NVDA":  r'(?<![A-Z0-9])\$?NVDA(?![A-Z0-9])|\bNVIDIA\b',
    "TSLA":  r'(?<![A-Z0-9])\$?TSLA(?![A-Z0-9])|\bTesla\b',
    "SPY":   r'(?<![A-Z0-9])\$?SPY(?![A-Z0-9])|\bSPDR\s+S&P\s*500\s+ETF(?:\s+Trust)?\b',
    "S&P500": r'(?:\^GSPC)|\bS&P\s*500\b'
}

def one_hot_companies(text_series: pd.Series,
                      patterns: dict = PATTERNS) -> pd.DataFrame:
    """
    input: the series of the text of the news
    out: the one-hot DataFrame of the news
    """
    out = {}
    for tick, pat in patterns.items():
        out[tick] = (
            text_series.str.contains(pat, flags=re.IGNORECASE, regex=True, na=False)
            .astype('int8')
        )
    return pd.DataFrame(out, index=text_series.index)

cnbc_oh = one_hot_companies(cnbc['Headlines'])
guardian_oh = one_hot_companies(guardian['Headlines'])
reuters_oh = one_hot_companies(reuters['Headlines'])
# cnbc.loc[0]
cnbc = cnbc.join(cnbc_oh)
TICKERS[-1] = 'S&P500'
guardian = guardian.join(guardian_oh)
reuters = reuters.join(reuters_oh)

cnbc_tickers = cnbc[cnbc[TICKERS].any(axis=1)]
guardian_tickers = guardian[guardian[TICKERS].any(axis=1)]
reuters_tickers = reuters[reuters[TICKERS].any(axis=1)]

import re

M = {'jan':1,'feb':2,'mar':3,'apr':4,'may':5,'jun':6,'jul':7,'aug':8,'sep':9,'oct':10,'nov':11,'dec':12}

PAT1 = re.compile(r'\b([A-Za-z]{3})\s+(\d{1,2})\s+(\d{4})\b')        # Jul 18 2020
PAT2 = re.compile(r'\b(\d{1,2})-([A-Za-z]{3})-(\d{2,4})\b')          # 18-Dec-17/2017
PAT3 = re.compile(r'\b(\d{1,2})\s+([A-Za-z]{3})\s+(\d{4})\b')        # ... Tue, 2 Jan 2018

def norm_y(y): y=int(y); return (2000+y if y<70 else 1900+y) if y<100 else y
def iso(s:str):
    if ',' in s:
      s = s.split(',')[-1]
    if not isinstance(s,str): return None
    for p in (PAT1,PAT2,PAT3):
        m=p.search(s);
        if m:
            a,b,c=m.groups()
            if p is PAT1: mth,day,yr=a,b,c
            elif p is PAT2: day,mth,yr=a,b,c
            else: day,mth,yr=a,b,c
            mnum=M.get(mth.lower(),None)
            if not mnum: return None
            return f"{norm_y(yr):04d}-{mnum:02d}-{int(day):02d}"
    return None

cnbc_tickers['Date']= cnbc_tickers['Time'].map(iso);
guardian_tickers['Date']= guardian_tickers['Time'].map(iso);
reuters_tickers['Date']= reuters_tickers['Time'].map(iso);

cnbc_tickers

guardian_tickers

reuters_tickers